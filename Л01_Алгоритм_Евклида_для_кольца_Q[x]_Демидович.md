# Лабораторная работа № 1. Алгоритм Евклида

Лит-ра: Алгебра, лек. 6. 

Реализация алгоритма Евклдиа для кольца $\mathbb{Q}[x]$. 


```python
def quo_rem_poly(f,q):
    K=f.parent()
    n=0
    while f.degree()>=q.degree():
        ni=K(f.lt()/q.lt())
        n=n+ni
        f=f-ni*q
    return (n,f)
```

**1. Какого типа данные подаются на вход? Какого типа данные возвращаются? Описать каждую строку алгоритма.**

На вход подаются данные строкового типа - многочлены. Возвращаются данные такого же типа, т.к это частное и остаток от деления.

В первой строке задается функция и входные данные - два многочлена, делимое и делитель.
Во второй строке определяется поле, в котором мы будем работать.
Далее мы задаем нулевое значение выражения и оно напрямую зависит от коэффициентов в делимом.
В 4-й строке задается следующее условие: наш многочлен f будет меняться и алгоритм будет выполняться, пока степень f больше степени q.
Затем отдельно прописывается результат от деления старшего монома делимого на старший моном делитель, а также кольцо, которому должен будет принадлежать результат.
В 6-й строке формируется частное, оно будет выглядеть как многочлен, состоящий из результатов деления старших мономов делимого и делителя.
И далее записывается остаток, который будет участвовать в следующей операции.

2. Проверить работу для $\mathbb{Q}[x]$


```python
f=x^9+x+2+4*x
q=x-1
quo_rem_poly(QQ[x](f),QQ[x](q))
```




    (x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 6, 8)



Проверка: $f=uq+r$.


```python
(u,r)=quo_rem_poly(QQ[x](f),QQ[x](q))
QQ[x](f-u*q-r)
```




    0



Встроенная в Sage реализация:


```python
QQ[x](f).quo_rem(QQ[x](q))
```




    (x^2 + x + 2, 4)



3. Проверить работу для $\mathbb{Q}[t]$


```python
var("t")
f=t^3+t+2
q=t-1
quo_rem_poly(QQ[t](f),QQ[t](q))
```




    (t^2 + t + 2, 4)



**Вопрос: зачем нужно писать var("t")?**

Необходимо писать "var("t")" для того, чтобы Sage определил ранее не заданную переменную t.

4. Проверить работу над $GF(p)[x]$. 


```python
f=7*x^3+x+2
q=x-1
k=GF(5)
quo_rem_poly(k[x](f),k[x](q))
```




    (2*x^2 + 2*x + 3, 0)



Проверка: $f=uq+r$.


```python
(u,r)=quo_rem_poly(k[x](f),k[x](q))
k[x](f)-u*k[x](q)-r
```




    0



**Вопрос: почему нельзя писать u*q?**

Нельзя писать u*q, поскольку в таком случае операция будет проведена не в поле Галуа и будет определяться по заданным многочленам

5. Проверить работу над $k[y]$, где $k$ -- поле частных кольца $\mathbb{Q}[x]$.


```python
var("x,y")
f=x^2*y^2+(x-1)*y+1
q=x*y-1
k=FractionField(QQ[x])
quo_rem_poly(k[y](f),k[y](q))
```




    (x*y + (2*x - 1)/x, (3*x - 1)/x)




```python
(u,r)=quo_rem_poly(k[y](f),k[y](q))
k[y](f)-u*k[y](q)-r
```




    0



6. Напишите программу для тестирования алгоритма в $\mathbb{Q}[x]$.


```python
def test_quo_rem():
    K=QQ[x]
    u=QQ[x].random_element()
    r=QQ[x].random_element()
    q=QQ[x].random_element()
    f=u*q+r
    print((f,q))
    (uu,rr)=quo_rem_poly(K(f),K(q))
    if u==uu and rr==r:
        ans=True
    else:
        ans=False
    return ans
```


```python
test_quo_rem()
```

    (-1/2*x^2 + 77/26*x + 2/13, x - 4)





    False



**Вопрос: должен ли алгоритм работать при $\partial q=0$ и при $\partial q=-1$? Как сделать защиту от "дурака"?**

Нет, т.к при степени делителя 0 и -1 алгоритм не будет работать. Для того, чтобы исключить подобную ошибку, нужно вставить строку с проверкой того, чтобы степени выбранного случайным образом многочлена q не была равна 0 или -1.

7. Оцените время, потребное на работу реализации алгоритма, при "больших" степенях. 


```python
var("x")
f=sum([(n+1)*x^n for n in range(10^3)])
q=sum([x^n for n in range(20)])
%timeit quo_rem_poly(QQ[x](f),QQ[x](q))
```

    360 ms ± 25.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)


Замечание. Elapsed real time, real time, wall-clock time, wall time, or walltime is the actual time taken from the start of a computer program to the end. In other words, it is the difference between the time at which a task finishes and the time at which the task started.

Время для расчета подобных степеней я считаю весьма малым, но конечно же, с ростом степени время работы будет увеличиваться


```python

```
